// Generated by purs bundle 0.14.4
var PS = {};
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var apply = function (dict) {
      return dict.apply;
  };
  exports["apply"] = apply;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];          
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Data_Function = $PS["Data.Function"];          
  var discard = function (dict) {
      return dict.discard;
  };
  var bind = function (dict) {
      return dict.bind;
  };
  var bindFlipped = function (dictBind) {
      return Data_Function.flip(bind(dictBind));
  };
  var discardUnit = {
      discard: function (dictBind) {
          return bind(dictBind);
      }
  };
  exports["bind"] = bind;
  exports["bindFlipped"] = bindFlipped;
  exports["discard"] = discard;
  exports["discardUnit"] = discardUnit;
})(PS);
(function(exports) {
  exports.dispatchCustomEvent = function (type) {
    return function (obj) {
      return function () {
        return document.dispatchEvent(
          new CustomEvent(type, { bubles: false, cancelable: false, detail: obj })
        )
      }
    }
  }

  exports.detail = function (evt) {
    return evt.detail
  }

  exports.logAny = function (obj) {
    return function () {
      return console.log(obj)
    }
  }
})(PS["CustomEvent"] = PS["CustomEvent"] || {});
(function($PS) {
  "use strict";
  $PS["CustomEvent"] = $PS["CustomEvent"] || {};
  var exports = $PS["CustomEvent"];
  var $foreign = $PS["CustomEvent"];                     
  var err = $foreign.dispatchCustomEvent("error-custom");
  var elemNotFound = function (str) {
      return {
          error: "Element not found",
          description: "Missing element with id='" + (str + "'.")
      };
  };
  exports["err"] = err;
  exports["elemNotFound"] = elemNotFound;
  exports["detail"] = $foreign.detail;
  exports["logAny"] = $foreign.logAny;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var Data_Function = $PS["Data.Function"];
  var Data_Unit = $PS["Data.Unit"];                  
  var map = function (dict) {
      return dict.map;
  };
  var $$void = function (dictFunctor) {
      return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };
  exports["map"] = map;
  exports["void"] = $$void;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Data_Functor = $PS["Data.Functor"];          
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var functorMaybe = {
      map: function (v) {
          return function (v1) {
              if (v1 instanceof Just) {
                  return new Just(v(v1.value0));
              };
              return Nothing.value;
          };
      }
  };
  var applyMaybe = {
      apply: function (v) {
          return function (v1) {
              if (v instanceof Just) {
                  return Data_Functor.map(functorMaybe)(v.value0)(v1);
              };
              if (v instanceof Nothing) {
                  return Nothing.value;
              };
              throw new Error("Failed pattern match at Data.Maybe (line 68, column 1 - line 70, column 30): " + [ v.constructor.name, v1.constructor.name ]);
          };
      },
      Functor0: function () {
          return functorMaybe;
      }
  };
  var bindMaybe = {
      bind: function (v) {
          return function (v1) {
              if (v instanceof Just) {
                  return v1(v.value0);
              };
              if (v instanceof Nothing) {
                  return Nothing.value;
              };
              throw new Error("Failed pattern match at Data.Maybe (line 126, column 1 - line 128, column 28): " + [ v.constructor.name, v1.constructor.name ]);
          };
      },
      Apply0: function () {
          return applyMaybe;
      }
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["bindMaybe"] = bindMaybe;
})(PS);
(function(exports) {
  /*! @license DOMPurify 2.3.2 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.2/LICENSE */

  'use strict'

  var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
  var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args)
    }
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x
    }
  }

  if (!seal) {
    seal = function seal(x) {
      return x
    }
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(
        Func,
        [null].concat(_toConsumableArray(args))
      ))()
    }
  }

  var arrayForEach = unapply(Array.prototype.forEach)
  var arrayPop = unapply(Array.prototype.pop)
  var arrayPush = unapply(Array.prototype.push)

  var stringToLowerCase = unapply(String.prototype.toLowerCase)
  var stringMatch = unapply(String.prototype.match)
  var stringReplace = unapply(String.prototype.replace)
  var stringIndexOf = unapply(String.prototype.indexOf)
  var stringTrim = unapply(String.prototype.trim)

  var regExpTest = unapply(RegExp.prototype.test)

  var typeErrorCreate = unconstruct(TypeError)

  function unapply(func) {
    return function (thisArg) {
      for (var
            _len = arguments.length,
          args = Array(_len > 1 ? _len - 1 : 0),
          _key = 1;
        _key < _len;
        _key++
      ) {
        args[_key - 1] = arguments[_key]
      }

      return apply(func, thisArg, args)
    }
  }

  function unconstruct(func) {
    return function () {
      for (var
            _len2 = arguments.length, args = Array(_len2), _key2 = 0;
        _key2 < _len2;
        _key2++
      ) {
        args[_key2] = arguments[_key2]
      }

      return construct(func, args)
    }
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null)
    }

    var l = array.length
    while (l--) {
      var element = array[l]
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element)
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement
          }

          element = lcElement
        }
      }

      set[element] = true
    }

    return set
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null)

    var property = void 0
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property]
      }
    }

    return newObject
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */  
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop)
      if (desc) {
        if (desc.get) {
          return unapply(desc.get)
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value)
        }
      }

      object = getPrototypeOf(object)
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element)
      return null
    }

    return fallbackValue
  }

  var html = freeze([
    'a',
    'abbr',
    'acronym',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'bdi',
    'bdo',
    'big',
    'blink',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'center',
    'cite',
    'code',
    'col',
    'colgroup',
    'content',
    'data',
    'datalist',
    'dd',
    'decorator',
    'del',
    'details',
    'dfn',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'element',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meter',
    'nav',
    'nobr',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'section',
    'select',
    'shadow',
    'small',
    'source',
    'spacer',
    'span',
    'strike',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'track',
    'tt',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
  ])

  // SVG
  var svg = freeze([
    'svg',
    'a',
    'altglyph',
    'altglyphdef',
    'altglyphitem',
    'animatecolor',
    'animatemotion',
    'animatetransform',
    'circle',
    'clippath',
    'defs',
    'desc',
    'ellipse',
    'filter',
    'font',
    'g',
    'glyph',
    'glyphref',
    'hkern',
    'image',
    'line',
    'lineargradient',
    'marker',
    'mask',
    'metadata',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialgradient',
    'rect',
    'stop',
    'style',
    'switch',
    'symbol',
    'text',
    'textpath',
    'title',
    'tref',
    'tspan',
    'view',
    'vkern',
  ])

  var svgFilters = freeze([
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
  ])

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze([
    'animate',
    'color-profile',
    'cursor',
    'discard',
    'fedropshadow',
    'feimage',
    'font-face',
    'font-face-format',
    'font-face-name',
    'font-face-src',
    'font-face-uri',
    'foreignobject',
    'hatch',
    'hatchpath',
    'mesh',
    'meshgradient',
    'meshpatch',
    'meshrow',
    'missing-glyph',
    'script',
    'set',
    'solidcolor',
    'unknown',
    'use',
  ])

  var mathMl = freeze([
    'math',
    'menclose',
    'merror',
    'mfenced',
    'mfrac',
    'mglyph',
    'mi',
    'mlabeledtr',
    'mmultiscripts',
    'mn',
    'mo',
    'mover',
    'mpadded',
    'mphantom',
    'mroot',
    'mrow',
    'ms',
    'mspace',
    'msqrt',
    'mstyle',
    'msub',
    'msup',
    'msubsup',
    'mtable',
    'mtd',
    'mtext',
    'mtr',
    'munder',
    'munderover',
  ])

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze([
    'maction',
    'maligngroup',
    'malignmark',
    'mlongdiv',
    'mscarries',
    'mscarry',
    'msgroup',
    'mstack',
    'msline',
    'msrow',
    'semantics',
    'annotation',
    'annotation-xml',
    'mprescripts',
    'none',
  ])

  var text = freeze(['#text'])

  var html$1 = freeze([
    'accept',
    'action',
    'align',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autopictureinpicture',
    'autoplay',
    'background',
    'bgcolor',
    'border',
    'capture',
    'cellpadding',
    'cellspacing',
    'checked',
    'cite',
    'class',
    'clear',
    'color',
    'cols',
    'colspan',
    'controls',
    'controlslist',
    'coords',
    'crossorigin',
    'datetime',
    'decoding',
    'default',
    'dir',
    'disabled',
    'disablepictureinpicture',
    'disableremoteplayback',
    'download',
    'draggable',
    'enctype',
    'enterkeyhint',
    'face',
    'for',
    'headers',
    'height',
    'hidden',
    'high',
    'href',
    'hreflang',
    'id',
    'inputmode',
    'integrity',
    'ismap',
    'kind',
    'label',
    'lang',
    'list',
    'loading',
    'loop',
    'low',
    'max',
    'maxlength',
    'media',
    'method',
    'min',
    'minlength',
    'multiple',
    'muted',
    'name',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'optimum',
    'pattern',
    'placeholder',
    'playsinline',
    'poster',
    'preload',
    'pubdate',
    'radiogroup',
    'readonly',
    'rel',
    'required',
    'rev',
    'reversed',
    'role',
    'rows',
    'rowspan',
    'spellcheck',
    'scope',
    'selected',
    'shape',
    'size',
    'sizes',
    'span',
    'srclang',
    'start',
    'src',
    'srcset',
    'step',
    'style',
    'summary',
    'tabindex',
    'title',
    'translate',
    'type',
    'usemap',
    'valign',
    'value',
    'width',
    'xmlns',
    'slot',
  ])

  var svg$1 = freeze([
    'accent-height',
    'accumulate',
    'additive',
    'alignment-baseline',
    'ascent',
    'attributename',
    'attributetype',
    'azimuth',
    'basefrequency',
    'baseline-shift',
    'begin',
    'bias',
    'by',
    'class',
    'clip',
    'clippathunits',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cx',
    'cy',
    'd',
    'dx',
    'dy',
    'diffuseconstant',
    'direction',
    'display',
    'divisor',
    'dur',
    'edgemode',
    'elevation',
    'end',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'filterunits',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'fx',
    'fy',
    'g1',
    'g2',
    'glyph-name',
    'glyphref',
    'gradientunits',
    'gradienttransform',
    'height',
    'href',
    'id',
    'image-rendering',
    'in',
    'in2',
    'k',
    'k1',
    'k2',
    'k3',
    'k4',
    'kerning',
    'keypoints',
    'keysplines',
    'keytimes',
    'lang',
    'lengthadjust',
    'letter-spacing',
    'kernelmatrix',
    'kernelunitlength',
    'lighting-color',
    'local',
    'marker-end',
    'marker-mid',
    'marker-start',
    'markerheight',
    'markerunits',
    'markerwidth',
    'maskcontentunits',
    'maskunits',
    'max',
    'mask',
    'media',
    'method',
    'mode',
    'min',
    'name',
    'numoctaves',
    'offset',
    'operator',
    'opacity',
    'order',
    'orient',
    'orientation',
    'origin',
    'overflow',
    'paint-order',
    'path',
    'pathlength',
    'patterncontentunits',
    'patterntransform',
    'patternunits',
    'points',
    'preservealpha',
    'preserveaspectratio',
    'primitiveunits',
    'r',
    'rx',
    'ry',
    'radius',
    'refx',
    'refy',
    'repeatcount',
    'repeatdur',
    'restart',
    'result',
    'rotate',
    'scale',
    'seed',
    'shape-rendering',
    'specularconstant',
    'specularexponent',
    'spreadmethod',
    'startoffset',
    'stddeviation',
    'stitchtiles',
    'stop-color',
    'stop-opacity',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke',
    'stroke-width',
    'style',
    'surfacescale',
    'systemlanguage',
    'tabindex',
    'targetx',
    'targety',
    'transform',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'textlength',
    'type',
    'u1',
    'u2',
    'unicode',
    'values',
    'viewbox',
    'visibility',
    'version',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'width',
    'word-spacing',
    'wrap',
    'writing-mode',
    'xchannelselector',
    'ychannelselector',
    'x',
    'x1',
    'x2',
    'xmlns',
    'y',
    'y1',
    'y2',
    'z',
    'zoomandpan',
  ])

  var mathMl$1 = freeze([
    'accent',
    'accentunder',
    'align',
    'bevelled',
    'close',
    'columnsalign',
    'columnlines',
    'columnspan',
    'denomalign',
    'depth',
    'dir',
    'display',
    'displaystyle',
    'encoding',
    'fence',
    'frame',
    'height',
    'href',
    'id',
    'largeop',
    'length',
    'linethickness',
    'lspace',
    'lquote',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'numalign',
    'open',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'rquote',
    'scriptlevel',
    'scriptminsize',
    'scriptsizemultiplier',
    'selection',
    'separator',
    'separators',
    'stretchy',
    'subscriptshift',
    'supscriptshift',
    'symmetric',
    'voffset',
    'width',
    'xmlns',
  ])

  var xml = freeze([
    'xlink:href',
    'xml:id',
    'xlink:title',
    'xml:space',
    'xmlns:xlink',
  ])

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm) // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm)
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/) // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/) // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  )
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i)
  var ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  )

  var _typeof =
    typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
      ? function (obj) {
          return typeof obj
        }
      : function (obj) {
          return obj &&
            typeof Symbol === 'function' &&
            obj.constructor === Symbol &&
            obj !== Symbol.prototype
            ? 'symbol'
            : typeof obj
        }

  function _toConsumableArray$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i]
      }
      return arr2
    } else {
      return Array.from(arr)
    }
  }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window
  }

  /**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */  
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(
    trustedTypes,
    document
  ) {
    if (
      (typeof trustedTypes === 'undefined'
        ? 'undefined'
        : _typeof(trustedTypes)) !== 'object' ||
      typeof trustedTypes.createPolicy !== 'function'
    ) {
      return null
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null
    var ATTR_NAME = 'data-tt-policy-suffix'
    if (
      document.currentScript &&
      document.currentScript.hasAttribute(ATTR_NAME)
    ) {
      suffix = document.currentScript.getAttribute(ATTR_NAME)
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '')

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1
        },
      })
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.')
      return null
    }
  }

  function createDOMPurify() {
    var window =
      arguments.length > 0 && arguments[0] !== undefined
        ? arguments[0]
        : getGlobal()

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root)
    }

    /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */  
    DOMPurify.version = '2.3.2'

    /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */  
    DOMPurify.removed = []

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false

      return DOMPurify
    }

    var originalDocument = window.document

    var document = window.document
    var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap =
        _window$NamedNodeMap === undefined
          ? window.NamedNodeMap || window.MozNamedAttrMap
          : _window$NamedNodeMap,
      Text = window.Text,
      Comment = window.Comment,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes

    var ElementPrototype = Element.prototype

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode')
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling')
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes')
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode')

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template')
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(
      trustedTypes,
      originalDocument
    )
    var emptyHTML =
      trustedTypesPolicy && RETURN_TRUSTED_TYPE
        ? trustedTypesPolicy.createHTML('')
        : ''

    var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName
    var importNode = originalDocument.importNode

    var documentMode = {}
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {}
    } catch (_) {}

    var hooks = {}

    /**
   * Expose whether this browser supports running the full DOMPurify.
   */  
    DOMPurify.isSupported =
      typeof getParentNode === 'function' &&
      implementation &&
      typeof implementation.createHTMLDocument !== 'undefined' &&
      documentMode !== 9

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI

    /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */  

    /* allowed element names */

    var ALLOWED_TAGS = null
    var DEFAULT_ALLOWED_TAGS = addToSet(
      {},
      [].concat(
        _toConsumableArray$1(html),
        _toConsumableArray$1(svg),
        _toConsumableArray$1(svgFilters),
        _toConsumableArray$1(mathMl),
        _toConsumableArray$1(text)
      )
    )

    /* Allowed attribute names */
    var ALLOWED_ATTR = null
    var DEFAULT_ALLOWED_ATTR = addToSet(
      {},
      [].concat(
        _toConsumableArray$1(html$1),
        _toConsumableArray$1(svg$1),
        _toConsumableArray$1(mathMl$1),
        _toConsumableArray$1(xml)
      )
    )

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false

    /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */  
    var SAFE_FOR_TEMPLATES = false

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false

    /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */  
    var FORCE_BODY = false

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */  
    var RETURN_DOM = false

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */  
    var RETURN_DOM_FRAGMENT = false

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify.
   *
   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
   * might cause XSS from attacks hidden in closed shadowroots in case the browser
   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
   */  
    var RETURN_DOM_IMPORT = true

    /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */  
    var RETURN_TRUSTED_TYPE = false

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */  
    var IN_PLACE = false

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {}

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null
    var DEFAULT_FORBID_CONTENTS = addToSet({}, [
      'annotation-xml',
      'audio',
      'colgroup',
      'desc',
      'foreignobject',
      'head',
      'iframe',
      'math',
      'mi',
      'mn',
      'mo',
      'ms',
      'mtext',
      'noembed',
      'noframes',
      'noscript',
      'plaintext',
      'script',
      'style',
      'svg',
      'template',
      'thead',
      'title',
      'video',
      'xmp',
    ])

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null
    var DEFAULT_DATA_URI_TAGS = addToSet({}, [
      'audio',
      'video',
      'img',
      'source',
      'image',
      'track',
    ])

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
      'alt',
      'class',
      'for',
      'id',
      'label',
      'name',
      'pattern',
      'placeholder',
      'role',
      'summary',
      'title',
      'value',
      'style',
      'xmlns',
    ])

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML'
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg'
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml'
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE
    var IS_EMPTY_INPUT = false

    /* Parsing of strict XHTML documents */
    var PARSER_MEDIA_TYPE = void 0
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html']
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html'
    var transformCaseFunc = void 0

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form')

    /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */  
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return
      }

      /* Shield configuration object from tampering */
      if (
        !cfg ||
        (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object'
      ) {
        cfg = {}
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg)

      /* Set configuration parameters */
      ALLOWED_TAGS =
        'ALLOWED_TAGS' in cfg
          ? addToSet({}, cfg.ALLOWED_TAGS)
          : DEFAULT_ALLOWED_TAGS
      ALLOWED_ATTR =
        'ALLOWED_ATTR' in cfg
          ? addToSet({}, cfg.ALLOWED_ATTR)
          : DEFAULT_ALLOWED_ATTR
      URI_SAFE_ATTRIBUTES =
        'ADD_URI_SAFE_ATTR' in cfg
          ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR)
          : DEFAULT_URI_SAFE_ATTRIBUTES
      DATA_URI_TAGS =
        'ADD_DATA_URI_TAGS' in cfg
          ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS)
          : DEFAULT_DATA_URI_TAGS
      FORBID_CONTENTS =
        'FORBID_CONTENTS' in cfg
          ? addToSet({}, cfg.FORBID_CONTENTS)
          : DEFAULT_FORBID_CONTENTS
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {}
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {}
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false // Default false
      RETURN_DOM = cfg.RETURN_DOM || false // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false // Default true
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false // Default false
      FORCE_BODY = cfg.FORCE_BODY || false // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false // Default true
      IN_PLACE = cfg.IN_PLACE || false // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE
      PARSER_MEDIA_TYPE =
        cfg.PARSER_MEDIA_TYPE in SUPPORTED_PARSER_MEDIA_TYPES
          ? cfg.PARSER_MEDIA_TYPE
          : DEFAULT_PARSER_MEDIA_TYPE
      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc =
        PARSER_MEDIA_TYPE === 'application/xhtml+xml'
          ? function (x) {
              return x
            }
          : stringToLowerCase

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)))
        ALLOWED_ATTR = []
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html)
          addToSet(ALLOWED_ATTR, html$1)
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg)
          addToSet(ALLOWED_ATTR, svg$1)
          addToSet(ALLOWED_ATTR, xml)
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters)
          addToSet(ALLOWED_ATTR, svg$1)
          addToSet(ALLOWED_ATTR, xml)
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl)
          addToSet(ALLOWED_ATTR, mathMl$1)
          addToSet(ALLOWED_ATTR, xml)
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS)
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS)
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR)
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR)
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR)
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS)
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS)
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body'])
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody'])
        delete FORBID_TAGS.tbody
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg)
      }

      CONFIG = cfg
    }

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
      'mi',
      'mo',
      'mn',
      'ms',
      'mtext',
    ])

    var HTML_INTEGRATION_POINTS = addToSet({}, [
      'foreignobject',
      'desc',
      'title',
      'annotation-xml',
    ])

    /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */  
    var ALL_SVG_TAGS = addToSet({}, svg)
    addToSet(ALL_SVG_TAGS, svgFilters)
    addToSet(ALL_SVG_TAGS, svgDisallowed)

    var ALL_MATHML_TAGS = addToSet({}, mathMl)
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed)

    /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */  
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element)

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template',
        }
      }

      var tagName = stringToLowerCase(element.tagName)
      var parentTagName = stringToLowerCase(parent.tagName)

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg'
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return (
            tagName === 'svg' &&
            (parentTagName === 'annotation-xml' ||
              MATHML_TEXT_INTEGRATION_POINTS[parentTagName])
          )
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName])
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math'
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName]
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName])
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (
          parent.namespaceURI === SVG_NAMESPACE &&
          !HTML_INTEGRATION_POINTS[parentTagName]
        ) {
          return false
        }

        if (
          parent.namespaceURI === MATHML_NAMESPACE &&
          !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]
        ) {
          return false
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, [
          'title',
          'style',
          'font',
          'a',
          'script',
        ])

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return (
          !ALL_MATHML_TAGS[tagName] &&
          (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName])
        )
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false
    }

    /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */  
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node })
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node)
      } catch (_) {
        try {
          node.outerHTML = emptyHTML
        } catch (_) {
          node.remove()
        }
      }
    }

    /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */  
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node,
        })
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node,
        })
      }

      node.removeAttribute(name)

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node)
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '')
          } catch (_) {}
        }
      }
    }

    /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */  
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0
      var leadingWhitespace = void 0

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/)
        leadingWhitespace = matches && matches[0]
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty =
          '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
          dirty +
          '</body></html>'
      }

      var dirtyPayload = trustedTypesPolicy
        ? trustedTypesPolicy.createHTML(dirty)
        : dirty
      /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */  
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE)
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null)
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement

      if (dirty && leadingWhitespace) {
        body.insertBefore(
          document.createTextNode(leadingWhitespace),
          body.childNodes[0] || null
        )
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0]
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body
    }

    /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */  
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
        null,
        false
      )
    }

    /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */  
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false
      }

      if (
        typeof elm.nodeName !== 'string' ||
        typeof elm.textContent !== 'string' ||
        typeof elm.removeChild !== 'function' ||
        !(elm.attributes instanceof NamedNodeMap) ||
        typeof elm.removeAttribute !== 'function' ||
        typeof elm.setAttribute !== 'function' ||
        typeof elm.namespaceURI !== 'string' ||
        typeof elm.insertBefore !== 'function'
      ) {
        return true
      }

      return false
    }

    /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */  
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) ===
        'object'
        ? object instanceof Node
        : object &&
            (typeof object === 'undefined' ? 'undefined' : _typeof(object)) ===
              'object' &&
            typeof object.nodeType === 'number' &&
            typeof object.nodeName === 'string'
    }

    /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */  
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG)
      })
    }

    /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */  
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null)

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode)
        return true
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode)
        return true
      }

      /* Now let's check the element's type and name */
      var tagName = transformCaseFunc(currentNode.nodeName)

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS,
      })

      /* Detect mXSS attempts abusing namespace confusion */
      if (
        !_isNode(currentNode.firstElementChild) &&
        (!_isNode(currentNode.content) ||
          !_isNode(currentNode.content.firstElementChild)) &&
        regExpTest(/<[/\w]/g, currentNode.innerHTML) &&
        regExpTest(/<[/\w]/g, currentNode.textContent)
      ) {
        _forceRemove(currentNode)
        return true
      }

      /* Mitigate a problem with templates inside select */
      if (
        tagName === 'select' &&
        regExpTest(/<template/i, currentNode.innerHTML)
      ) {
        _forceRemove(currentNode)
        return true
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes

          if (childNodes && parentNode) {
            var childCount = childNodes.length

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(
                cloneNode(childNodes[i], true),
                getNextSibling(currentNode)
              )
            }
          }
        }

        _forceRemove(currentNode)
        return true
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode)
        return true
      }

      if (
        (tagName === 'noscript' || tagName === 'noembed') &&
        regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)
      ) {
        _forceRemove(currentNode)
        return true
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ')
        content = stringReplace(content, ERB_EXPR$$1, ' ')
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() })
          currentNode.textContent = content
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null)

      return false
    }

    /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */  
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (
        SANITIZE_DOM &&
        (lcName === 'id' || lcName === 'name') &&
        (value in document || value in formElement)
      ) {
        return false
      }

      /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */  
      if (
        ALLOW_DATA_ATTR &&
        !FORBID_ATTR[lcName] &&
        regExpTest(DATA_ATTR$$1, lcName)
      );
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName));
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]);
      else if (
        regExpTest(
          IS_ALLOWED_URI$$1,
          stringReplace(value, ATTR_WHITESPACE$$1, '')
        )
      );
      else if (
        (lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') &&
        lcTag !== 'script' &&
        stringIndexOf(value, 'data:') === 0 &&
        DATA_URI_TAGS[lcTag]
      );
      else if (
        ALLOW_UNKNOWN_PROTOCOLS &&
        !regExpTest(
          IS_SCRIPT_OR_DATA$$1,
          stringReplace(value, ATTR_WHITESPACE$$1, '')
        )
      );
      else if (!value);
      else {
        return false
      }

      return true
    }

    /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */  
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0
      var value = void 0
      var lcName = void 0
      var l = void 0
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null)

      var attributes = currentNode.attributes

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
      }
      l = attributes.length

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l]
        var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI

        value = stringTrim(attr.value)
        lcName = transformCaseFunc(name)

        /* Execute a hook if present */
        hookEvent.attrName = lcName
        hookEvent.attrValue = value
        hookEvent.keepAttr = true
        hookEvent.forceKeepAttr = undefined // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent)
        value = hookEvent.attrValue
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode)

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode)
          continue
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ')
          value = stringReplace(value, ERB_EXPR$$1, ' ')
        }

        /* Is `value` valid for this attribute? */
        var lcTag = transformCaseFunc(currentNode.nodeName)
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value)
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value)
          }

          arrayPop(DOMPurify.removed)
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null)
    }

    /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */  
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0
      var shadowIterator = _createIterator(fragment)

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null)

      while ((shadowNode = shadowIterator.nextNode())) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null)

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content)
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode)
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null)
    }

    /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */  
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0
      var importedNode = void 0
      var currentNode = void 0
      var oldNode = void 0
      var returnNode = void 0
      /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */  
      IS_EMPTY_INPUT = !dirty
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->'
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function')
        } else {
          dirty = dirty.toString()
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting')
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (
          _typeof(window.toStaticHTML) === 'object' ||
          typeof window.toStaticHTML === 'function'
        ) {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty)
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML)
          }
        }

        return dirty
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg)
      }

      /* Clean up removed elements */
      DOMPurify.removed = []

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false
      }

      if (IN_PLACE);
      else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */  
        body = _initDocument('<!---->')
        importedNode = body.ownerDocument.importNode(dirty, true)
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode)
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (
          !RETURN_DOM &&
          !SAFE_FOR_TEMPLATES &&
          !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1
        ) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE
            ? trustedTypesPolicy.createHTML(dirty)
            : dirty
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty)

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild)
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body)

      /* Now start iterating over the created document */
      while ((currentNode = nodeIterator.nextNode())) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content)
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode)

        oldNode = currentNode
      }

      oldNode = null

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument)

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild)
          }
        } else {
          returnNode = body
        }

        if (RETURN_DOM_IMPORT) {
          /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */  
          returnNode = importNode.call(originalDocument, returnNode, true)
        }

        return returnNode
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ')
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ')
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE
        ? trustedTypesPolicy.createHTML(serializedHTML)
        : serializedHTML
    }

    /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */  
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg)
      SET_CONFIG = true
    }

    /**
   * Public method to remove the configuration
   * clearConfig
   *
   */  
    DOMPurify.clearConfig = function () {
      CONFIG = null
      SET_CONFIG = false
    }

    /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */  
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({})
      }

      var lcTag = transformCaseFunc(tag)
      var lcName = transformCaseFunc(attr)
      return _isValidAttribute(lcTag, lcName, value)
    }

    /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */  
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return
      }

      hooks[entryPoint] = hooks[entryPoint] || []
      arrayPush(hooks[entryPoint], hookFunction)
    }

    /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */  
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint])
      }
    }

    /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */  
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = []
      }
    }

    /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */  
    DOMPurify.removeAllHooks = function () {
      hooks = {}
    }

    return DOMPurify
  }

  var purify = createDOMPurify()

  exports.sanitize = function (dirty) {
    return function () {
      return purify.sanitize(dirty, { USE_PROFILES: { html: true } })
    }
  }
})(PS["Dompurify"] = PS["Dompurify"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Dompurify"] = $PS["Dompurify"] || {};
  var exports = $PS["Dompurify"];
  var $foreign = $PS["Dompurify"];
  exports["sanitize"] = $foreign.sanitize;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["ap"] = ap;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Monad = $PS["Control.Monad"];                  
  var monadEffect = {
      Applicative0: function () {
          return applicativeEffect;
      },
      Bind1: function () {
          return bindEffect;
      }
  };
  var bindEffect = {
      bind: $foreign.bindE,
      Apply0: function () {
          return applyEffect;
      }
  };
  var applyEffect = {
      apply: Control_Monad.ap(monadEffect),
      Functor0: function () {
          return functorEffect;
      }
  };
  var applicativeEffect = {
      pure: $foreign.pureE,
      Apply0: function () {
          return applyEffect;
      }
  };
  var functorEffect = {
      map: Control_Applicative.liftA1(applicativeEffect)
  };
  exports["functorEffect"] = functorEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
  exports["monadEffect"] = monadEffect;
})(PS);
(function(exports) {
  /* globals setImmediate, clearImmediate, setTimeout, clearTimeout */
  /* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */
  "use strict";

  var Aff = function () {
    // A unique value for empty.
    var EMPTY = {};

    /*

  An awkward approximation. We elide evidence we would otherwise need in PS for
  efficiency sake.

  data Aff eff a
    = Pure a
    | Throw Error
    | Catch (Aff eff a) (Error -> Aff eff a)
    | Sync (Eff eff a)
    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))
    | forall b. Bind (Aff eff b) (b -> Aff eff a)
    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)
    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)
    | Sequential (ParAff aff a)

  */  
    var PURE    = "Pure";
    var THROW   = "Throw";
    var CATCH   = "Catch";
    var SYNC    = "Sync";
    var ASYNC   = "Async";
    var BIND    = "Bind";
    var BRACKET = "Bracket";
    var FORK    = "Fork";
    var SEQ     = "Sequential";

    /*

  data ParAff eff a
    = forall b. Map (b -> a) (ParAff eff b)
    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)
    | Alt (ParAff eff a) (ParAff eff a)
    | ?Par (Aff eff a)

  */  
    var MAP   = "Map";
    var APPLY = "Apply";
    var ALT   = "Alt";

    // Various constructors used in interpretation
    var CONS      = "Cons";      // Cons-list, for stacks
    var RESUME    = "Resume";    // Continue indiscriminately
    var RELEASE   = "Release";   // Continue with bracket finalizers
    var FINALIZER = "Finalizer"; // A non-interruptible effect
    var FINALIZED = "Finalized"; // Marker for finalization
    var FORKED    = "Forked";    // Reference to a forked fiber, with resumption stack
    var FIBER     = "Fiber";     // Actual fiber reference
    var THUNK     = "Thunk";     // Primed effect, ready to invoke

    function Aff(tag, _1, _2, _3) {
      this.tag = tag;
      this._1  = _1;
      this._2  = _2;
      this._3  = _3;
    }

    function AffCtr(tag) {
      var fn = function (_1, _2, _3) {
        return new Aff(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }

    function nonCanceler(error) {
      return new Aff(PURE, void 0);
    }

    function runEff(eff) {
      try {
        eff();
      } catch (error) {
        setTimeout(function () {
          throw error;
        }, 0);
      }
    }

    function runSync(left, right, eff) {
      try {
        return right(eff());
      } catch (error) {
        return left(error);
      }
    }

    function runAsync(left, eff, k) {
      try {
        return eff(k)();
      } catch (error) {
        k(left(error))();
        return nonCanceler;
      }
    }

    var Scheduler = function () {
      var limit    = 1024;
      var size     = 0;
      var ix       = 0;
      var queue    = new Array(limit);
      var draining = false;

      function drain() {
        var thunk;
        draining = true;
        while (size !== 0) {
          size--;
          thunk     = queue[ix];
          queue[ix] = void 0;
          ix        = (ix + 1) % limit;
          thunk();
        }
        draining = false;
      }

      return {
        isDraining: function () {
          return draining;
        },
        enqueue: function (cb) {
          var i, tmp;
          if (size === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }

          queue[(ix + size) % limit] = cb;
          size++;

          if (!draining) {
            drain();
          }
        }
      };
    }();

    function Supervisor(util) {
      var fibers  = {};
      var fiberId = 0;
      var count   = 0;

      return {
        register: function (fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function (result) {
              return function () {
                count--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count++;
        },
        isEmpty: function () {
          return count === 0;
        },
        killAll: function (killError, cb) {
          return function () {
            if (count === 0) {
              return cb();
            }

            var killCount = 0;
            var kills     = {};

            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function (result) {
                return function () {
                  delete kills[fid];
                  killCount--;
                  if (util.isLeft(result) && util.fromLeft(result)) {
                    setTimeout(function () {
                      throw util.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }

            for (var k in fibers) {
              if (fibers.hasOwnProperty(k)) {
                killCount++;
                kill(k);
              }
            }

            fibers  = {};
            fiberId = 0;
            count   = 0;

            return function (error) {
              return new Aff(SYNC, function () {
                for (var k in kills) {
                  if (kills.hasOwnProperty(k)) {
                    kills[k]();
                  }
                }
              });
            };
          };
        }
      };
    }

    // Fiber state machine
    var SUSPENDED   = 0; // Suspended, pending a join.
    var CONTINUE    = 1; // Interpret the next instruction.
    var STEP_BIND   = 2; // Apply the next bind.
    var STEP_RESULT = 3; // Handle potential failure from a result.
    var PENDING     = 4; // An async effect is running.
    var RETURN      = 5; // The current stack has returned.
    var COMPLETED   = 6; // The entire fiber has completed.

    function Fiber(util, supervisor, aff) {
      // Monotonically increasing tick, increased on each asynchronous turn.
      var runTick = 0;

      // The current branch of the state machine.
      var status = SUSPENDED;

      // The current point of interest for the state machine branch.
      var step      = aff;  // Successful step
      var fail      = null; // Failure step
      var interrupt = null; // Asynchronous interrupt

      // Stack of continuations for the current fiber.
      var bhead = null;
      var btail = null;

      // Stack of attempts and finalizers for error recovery. Every `Cons` is also
      // tagged with current `interrupt` state. We use this to track which items
      // should be ignored or evaluated as a result of a kill.
      var attempts = null;

      // A special state is needed for Bracket, because it cannot be killed. When
      // we enter a bracket acquisition or finalizer, we increment the counter,
      // and then decrement once complete.
      var bracketCount = 0;

      // Each join gets a new id so they can be revoked.
      var joinId  = 0;
      var joins   = null;
      var rethrow = true;

      // Each invocation of `run` requires a tick. When an asynchronous effect is
      // resolved, we must check that the local tick coincides with the fiber
      // tick before resuming. This prevents multiple async continuations from
      // accidentally resuming the same fiber. A common example may be invoking
      // the provided callback in `makeAff` more than once, but it may also be an
      // async effect resuming after the fiber was already cancelled.
      function run(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp       = null;
          result    = null;
          attempt   = null;

          switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step   = bhead(step);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail   = util.left(e);
              step   = null;
            }
            break;

          case STEP_RESULT:
            if (util.isLeft(step)) {
              status = RETURN;
              fail   = step;
              step   = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step   = util.fromRight(step);
            }
            break;

          case CONTINUE:
            switch (step.tag) {
            case BIND:
              if (bhead) {
                btail = new Aff(CONS, bhead, btail);
              }
              bhead  = step._2;
              status = CONTINUE;
              step   = step._1;
              break;

            case PURE:
              if (bhead === null) {
                status = RETURN;
                step   = util.right(step._1);
              } else {
                status = STEP_BIND;
                step   = step._1;
              }
              break;

            case SYNC:
              status = STEP_RESULT;
              step   = runSync(util.left, util.right, step._1);
              break;

            case ASYNC:
              status = PENDING;
              step   = runAsync(util.left, step._1, function (result) {
                return function () {
                  if (runTick !== localRunTick) {
                    return;
                  }
                  runTick++;
                  Scheduler.enqueue(function () {
                    // It's possible to interrupt the fiber between enqueuing and
                    // resuming, so we need to check that the runTick is still
                    // valid.
                    if (runTick !== localRunTick + 1) {
                      return;
                    }
                    status = STEP_RESULT;
                    step   = result;
                    run(runTick);
                  });
                };
              });
              return;

            case THROW:
              status = RETURN;
              fail   = util.left(step._1);
              step   = null;
              break;

            // Enqueue the Catch so that we can call the error handler later on
            // in case of an exception.
            case CATCH:
              if (bhead === null) {
                attempts = new Aff(CONS, step, attempts, interrupt);
              } else {
                attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);
              }
              bhead    = null;
              btail    = null;
              status   = CONTINUE;
              step     = step._1;
              break;

            // Enqueue the Bracket so that we can call the appropriate handlers
            // after resource acquisition.
            case BRACKET:
              bracketCount++;
              if (bhead === null) {
                attempts = new Aff(CONS, step, attempts, interrupt);
              } else {
                attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);
              }
              bhead  = null;
              btail  = null;
              status = CONTINUE;
              step   = step._1;
              break;

            case FORK:
              status = STEP_RESULT;
              tmp    = Fiber(util, supervisor, step._2);
              if (supervisor) {
                supervisor.register(tmp);
              }
              if (step._1) {
                tmp.run();
              }
              step = util.right(tmp);
              break;

            case SEQ:
              status = CONTINUE;
              step   = sequential(util, supervisor, step._1);
              break;
            }
            break;

          case RETURN:
            bhead = null;
            btail = null;
            // If the current stack has returned, and we have no other stacks to
            // resume or finalizers to run, the fiber has halted and we can
            // invoke all join callbacks. Otherwise we need to resume.
            if (attempts === null) {
              status = COMPLETED;
              step   = interrupt || fail || step;
            } else {
              // The interrupt status for the enqueued item.
              tmp      = attempts._3;
              attempt  = attempts._1;
              attempts = attempts._2;

              switch (attempt.tag) {
              // We cannot recover from an unmasked interrupt. Otherwise we should
              // continue stepping, or run the exception handler if an exception
              // was raised.
              case CATCH:
                // We should compare the interrupt status as well because we
                // only want it to apply if there has been an interrupt since
                // enqueuing the catch.
                if (interrupt && interrupt !== tmp && bracketCount === 0) {
                  status = RETURN;
                } else if (fail) {
                  status = CONTINUE;
                  step   = attempt._2(util.fromLeft(fail));
                  fail   = null;
                }
                break;

              // We cannot resume from an unmasked interrupt or exception.
              case RESUME:
                // As with Catch, we only want to ignore in the case of an
                // interrupt since enqueing the item.
                if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {
                  status = RETURN;
                } else {
                  bhead  = attempt._1;
                  btail  = attempt._2;
                  status = STEP_BIND;
                  step   = util.fromRight(step);
                }
                break;

              // If we have a bracket, we should enqueue the handlers,
              // and continue with the success branch only if the fiber has
              // not been interrupted. If the bracket acquisition failed, we
              // should not run either.
              case BRACKET:
                bracketCount--;
                if (fail === null) {
                  result   = util.fromRight(step);
                  // We need to enqueue the Release with the same interrupt
                  // status as the Bracket that is initiating it.
                  attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp);
                  // We should only coninue as long as the interrupt status has not changed or
                  // we are currently within a non-interruptable finalizer.
                  if (interrupt === tmp || bracketCount > 0) {
                    status = CONTINUE;
                    step   = attempt._3(result);
                  }
                }
                break;

              // Enqueue the appropriate handler. We increase the bracket count
              // because it should not be cancelled.
              case RELEASE:
                attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);
                status   = CONTINUE;
                // It has only been killed if the interrupt status has changed
                // since we enqueued the item, and the bracket count is 0. If the
                // bracket count is non-zero then we are in a masked state so it's
                // impossible to be killed.
                if (interrupt && interrupt !== tmp && bracketCount === 0) {
                  step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                } else if (fail) {
                  step = attempt._1.failed(util.fromLeft(fail))(attempt._2);
                } else {
                  step = attempt._1.completed(util.fromRight(step))(attempt._2);
                }
                fail = null;
                bracketCount++;
                break;

              case FINALIZER:
                bracketCount++;
                attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);
                status   = CONTINUE;
                step     = attempt._1;
                break;

              case FINALIZED:
                bracketCount--;
                status = RETURN;
                step   = attempt._1;
                fail   = attempt._2;
                break;
              }
            }
            break;

          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step));
              }
            }
            joins = null;
            // If we have an interrupt and a fail, then the thread threw while
            // running finalizers. This should always rethrow in a fresh stack.
            if (interrupt && fail) {
              setTimeout(function () {
                throw util.fromLeft(fail);
              }, 0);
            // If we have an unhandled exception, and no other fiber has joined
            // then we need to throw the exception in a fresh stack.
            } else if (util.isLeft(step) && rethrow) {
              setTimeout(function () {
                // Guard on reathrow because a completely synchronous fiber can
                // still have an observer which was added after-the-fact.
                if (rethrow) {
                  throw util.fromLeft(step);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING: return;
          }
        }
      }

      function onComplete(join) {
        return function () {
          if (status === COMPLETED) {
            rethrow = rethrow && join.rethrow;
            join.handler(step)();
            return function () {};
          }

          var jid    = joinId++;
          joins      = joins || {};
          joins[jid] = join;

          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }

      function kill(error, cb) {
        return function () {
          if (status === COMPLETED) {
            cb(util.right(void 0))();
            return function () {};
          }

          var canceler = onComplete({
            rethrow: false,
            handler: function (/* unused */) {
              return cb(util.right(void 0));
            }
          })();

          switch (status) {
          case SUSPENDED:
            interrupt = util.left(error);
            status    = COMPLETED;
            step      = interrupt;
            run(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);
              }
              status   = RETURN;
              step     = null;
              fail     = null;
              run(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step   = null;
              fail   = null;
            }
          }

          return canceler;
        };
      }

      function join(cb) {
        return function () {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run(runTick);
          }
          return canceler;
        };
      }

      return {
        kill: kill,
        join: join,
        onComplete: onComplete,
        isSuspended: function () {
          return status === SUSPENDED;
        },
        run: function () {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function () {
                run(runTick);
              });
            } else {
              run(runTick);
            }
          }
        }
      };
    }

    function runPar(util, supervisor, par, cb) {
      // Table of all forked fibers.
      var fiberId   = 0;
      var fibers    = {};

      // Table of currently running cancelers, as a product of `Alt` behavior.
      var killId    = 0;
      var kills     = {};

      // Error used for early cancelation on Alt branches.
      var early     = new Error("[ParAff] Early exit");

      // Error used to kill the entire tree.
      var interrupt = null;

      // The root pointer of the tree.
      var root      = EMPTY;

      // Walks a tree, invoking all the cancelers. Returns the table of pending
      // cancellation fibers.
      function kill(error, par, cb) {
        var step  = par;
        var head  = null;
        var tail  = null;
        var count = 0;
        var kills = {};
        var tmp, kid;

        loop: while (true) {
          tmp = null;

          switch (step.tag) {
          case FORKED:
            if (step._3 === EMPTY) {
              tmp = fibers[step._1];
              kills[count++] = tmp.kill(error, function (result) {
                return function () {
                  count--;
                  if (count === 0) {
                    cb(result)();
                  }
                };
              });
            }
            // Terminal case.
            if (head === null) {
              break loop;
            }
            // Go down the right side of the tree.
            step = head._2;
            if (tail === null) {
              head = null;
            } else {
              head = tail._1;
              tail = tail._2;
            }
            break;
          case MAP:
            step = step._2;
            break;
          case APPLY:
          case ALT:
            if (head) {
              tail = new Aff(CONS, head, tail);
            }
            head = step;
            step = step._1;
            break;
          }
        }

        if (count === 0) {
          cb(util.right(void 0))();
        } else {
          // Run the cancelation effects. We alias `count` because it's mutable.
          kid = 0;
          tmp = count;
          for (; kid < tmp; kid++) {
            kills[kid] = kills[kid]();
          }
        }

        return kills;
      }

      // When a fiber resolves, we need to bubble back up the tree with the
      // result, computing the applicative nodes.
      function join(result, head, tail) {
        var fail, step, lhs, rhs, tmp, kid;

        if (util.isLeft(result)) {
          fail = result;
          step = null;
        } else {
          step = result;
          fail = null;
        }

        loop: while (true) {
          lhs = null;
          rhs = null;
          tmp = null;
          kid = null;

          // We should never continue if the entire tree has been interrupted.
          if (interrupt !== null) {
            return;
          }

          // We've made it all the way to the root of the tree, which means
          // the tree has fully evaluated.
          if (head === null) {
            cb(fail || step)();
            return;
          }

          // The tree has already been computed, so we shouldn't try to do it
          // again. This should never happen.
          // TODO: Remove this?
          if (head._3 !== EMPTY) {
            return;
          }

          switch (head.tag) {
          case MAP:
            if (fail === null) {
              head._3 = util.right(head._1(util.fromRight(step)));
              step    = head._3;
            } else {
              head._3 = fail;
            }
            break;
          case APPLY:
            lhs = head._1._3;
            rhs = head._2._3;
            // If we have a failure we should kill the other side because we
            // can't possible yield a result anymore.
            if (fail) {
              head._3 = fail;
              tmp     = true;
              kid     = killId++;

              kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function (/* unused */) {
                return function () {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join(fail, null, null);
                  } else {
                    join(fail, tail._1, tail._2);
                  }
                };
              });

              if (tmp) {
                tmp = false;
                return;
              }
            } else if (lhs === EMPTY || rhs === EMPTY) {
              // We can only proceed if both sides have resolved.
              return;
            } else {
              step    = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
              head._3 = step;
            }
            break;
          case ALT:
            lhs = head._1._3;
            rhs = head._2._3;
            // We can only proceed if both have resolved or we have a success
            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
              return;
            }
            // If both sides resolve with an error, we should continue with the
            // first error
            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
              fail    = step === lhs ? rhs : lhs;
              step    = null;
              head._3 = fail;
            } else {
              head._3 = step;
              tmp     = true;
              kid     = killId++;
              // Once a side has resolved, we need to cancel the side that is still
              // pending before we can continue.
              kills[kid] = kill(early, step === lhs ? head._2 : head._1, function (/* unused */) {
                return function () {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail === null) {
                    join(step, null, null);
                  } else {
                    join(step, tail._1, tail._2);
                  }
                };
              });

              if (tmp) {
                tmp = false;
                return;
              }
            }
            break;
          }

          if (tail === null) {
            head = null;
          } else {
            head = tail._1;
            tail = tail._2;
          }
        }
      }

      function resolve(fiber) {
        return function (result) {
          return function () {
            delete fibers[fiber._1];
            fiber._3 = result;
            join(result, fiber._2._1, fiber._2._2);
          };
        };
      }

      // Walks the applicative tree, substituting non-applicative nodes with
      // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot
      // as a mutable slot for memoization. In an unresolved state, the `_3`
      // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk
      // the left side first, because both operations are left-associative. As
      // we `RETURN` from those branches, we then walk the right side.
      function run() {
        var status = CONTINUE;
        var step   = par;
        var head   = null;
        var tail   = null;
        var tmp, fid;

        loop: while (true) {
          tmp = null;
          fid = null;

          switch (status) {
          case CONTINUE:
            switch (step.tag) {
            case MAP:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(MAP, step._1, EMPTY, EMPTY);
              step = step._2;
              break;
            case APPLY:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(APPLY, EMPTY, step._2, EMPTY);
              step = step._1;
              break;
            case ALT:
              if (head) {
                tail = new Aff(CONS, head, tail);
              }
              head = new Aff(ALT, EMPTY, step._2, EMPTY);
              step = step._1;
              break;
            default:
              // When we hit a leaf value, we suspend the stack in the `FORKED`.
              // When the fiber resolves, it can bubble back up the tree.
              fid    = fiberId++;
              status = RETURN;
              tmp    = step;
              step   = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);
              tmp    = Fiber(util, supervisor, tmp);
              tmp.onComplete({
                rethrow: false,
                handler: resolve(step)
              })();
              fibers[fid] = tmp;
              if (supervisor) {
                supervisor.register(tmp);
              }
            }
            break;
          case RETURN:
            // Terminal case, we are back at the root.
            if (head === null) {
              break loop;
            }
            // If we are done with the right side, we need to continue down the
            // left. Otherwise we should continue up the stack.
            if (head._1 === EMPTY) {
              head._1 = step;
              status  = CONTINUE;
              step    = head._2;
              head._2 = EMPTY;
            } else {
              head._2 = step;
              step    = head;
              if (tail === null) {
                head  = null;
              } else {
                head  = tail._1;
                tail  = tail._2;
              }
            }
          }
        }

        // Keep a reference to the tree root so it can be cancelled.
        root = step;

        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }

      // Cancels the entire tree. If there are already subtrees being canceled,
      // we need to first cancel those joins. We will then add fresh joins for
      // all pending branches including those that were in the process of being
      // canceled.
      function cancel(error, cb) {
        interrupt = util.left(error);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }

        kills = null;
        var newKills = kill(error, root, cb);

        return function (killError) {
          return new Aff(ASYNC, function (killCb) {
            return function () {
              for (var kid in newKills) {
                if (newKills.hasOwnProperty(kid)) {
                  newKills[kid]();
                }
              }
              return nonCanceler;
            };
          });
        };
      }

      run();

      return function (killError) {
        return new Aff(ASYNC, function (killCb) {
          return function () {
            return cancel(killError, killCb);
          };
        });
      };
    }

    function sequential(util, supervisor, par) {
      return new Aff(ASYNC, function (cb) {
        return function () {
          return runPar(util, supervisor, par, cb);
        };
      });
    }

    Aff.EMPTY       = EMPTY;
    Aff.Pure        = AffCtr(PURE);
    Aff.Throw       = AffCtr(THROW);
    Aff.Catch       = AffCtr(CATCH);
    Aff.Sync        = AffCtr(SYNC);
    Aff.Async       = AffCtr(ASYNC);
    Aff.Bind        = AffCtr(BIND);
    Aff.Bracket     = AffCtr(BRACKET);
    Aff.Fork        = AffCtr(FORK);
    Aff.Seq         = AffCtr(SEQ);
    Aff.ParMap      = AffCtr(MAP);
    Aff.ParApply    = AffCtr(APPLY);
    Aff.ParAlt      = AffCtr(ALT);
    Aff.Fiber       = Fiber;
    Aff.Supervisor  = Supervisor;
    Aff.Scheduler   = Scheduler;
    Aff.nonCanceler = nonCanceler;

    return Aff;
  }();

  exports._pure = Aff.Pure;

  exports._map = function (f) {
    return function (aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f(aff._1));
      } else {
        return Aff.Bind(aff, function (value) {
          return Aff.Pure(f(value));
        });
      }
    };
  };

  exports._bind = function (aff) {
    return function (k) {
      return Aff.Bind(aff, k);
    };
  };

  exports._liftEffect = Aff.Sync;

  exports._makeFiber = function (util, aff) {
    return function () {
      return Aff.Fiber(util, null, aff);
    };
  };
})(PS["Effect.Aff"] = PS["Effect.Aff"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];                
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();
  exports["Left"] = Left;
  exports["Right"] = Right;
})(PS);
(function(exports) {
  "use strict";

  // module Partial.Unsafe

  exports._unsafePartial = function (f) {
    return f();
  };
})(PS["Partial.Unsafe"] = PS["Partial.Unsafe"] || {});
(function(exports) {
  "use strict";

  // module Partial

  exports._crashWith = function (msg) {
    throw new Error(msg);
  };
})(PS["Partial"] = PS["Partial"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Partial"] = $PS["Partial"] || {};
  var exports = $PS["Partial"];
  var $foreign = $PS["Partial"];         
  var crashWith = function (dictPartial) {
      return $foreign["_crashWith"];
  };
  exports["crashWith"] = crashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Partial.Unsafe"] = $PS["Partial.Unsafe"] || {};
  var exports = $PS["Partial.Unsafe"];
  var $foreign = $PS["Partial.Unsafe"];
  var Partial = $PS["Partial"];                
  var unsafePartial = $foreign["_unsafePartial"];
  var unsafeCrashWith = function (msg) {
      return unsafePartial(function (dictPartial) {
          return Partial.crashWith()(msg);
      });
  };
  exports["unsafeCrashWith"] = unsafeCrashWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Effect.Aff"] = $PS["Effect.Aff"] || {};
  var exports = $PS["Effect.Aff"];
  var $foreign = $PS["Effect.Aff"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Either = $PS["Data.Either"];
  var Data_Functor = $PS["Data.Functor"];
  var Effect = $PS["Effect"];
  var Partial_Unsafe = $PS["Partial.Unsafe"];
  var functorAff = {
      map: $foreign["_map"]
  };                                    
  var ffiUtil = (function () {
      var unsafeFromRight = function (v) {
          if (v instanceof Data_Either.Right) {
              return v.value0;
          };
          if (v instanceof Data_Either.Left) {
              return Partial_Unsafe.unsafeCrashWith("unsafeFromRight: Left");
          };
          throw new Error("Failed pattern match at Effect.Aff (line 404, column 21 - line 406, column 54): " + [ v.constructor.name ]);
      };
      var unsafeFromLeft = function (v) {
          if (v instanceof Data_Either.Left) {
              return v.value0;
          };
          if (v instanceof Data_Either.Right) {
              return Partial_Unsafe.unsafeCrashWith("unsafeFromLeft: Right");
          };
          throw new Error("Failed pattern match at Effect.Aff (line 399, column 20 - line 401, column 54): " + [ v.constructor.name ]);
      };
      var isLeft = function (v) {
          if (v instanceof Data_Either.Left) {
              return true;
          };
          if (v instanceof Data_Either.Right) {
              return false;
          };
          throw new Error("Failed pattern match at Effect.Aff (line 394, column 12 - line 396, column 20): " + [ v.constructor.name ]);
      };
      return {
          isLeft: isLeft,
          fromLeft: unsafeFromLeft,
          fromRight: unsafeFromRight,
          left: Data_Either.Left.create,
          right: Data_Either.Right.create
      };
  })();
  var makeFiber = function (aff) {
      return $foreign["_makeFiber"](ffiUtil, aff);
  };
  var launchAff = function (aff) {
      return function __do() {
          var fiber = makeFiber(aff)();
          fiber.run();
          return fiber;
      };
  };
  var launchAff_ = (function () {
      var $40 = Data_Functor["void"](Effect.functorEffect);
      return function ($41) {
          return $40(launchAff($41));
      };
  })();
  var monadAff = {
      Applicative0: function () {
          return applicativeAff;
      },
      Bind1: function () {
          return bindAff;
      }
  };
  var bindAff = {
      bind: $foreign["_bind"],
      Apply0: function () {
          return applyAff;
      }
  };
  var applyAff = {
      apply: Control_Monad.ap(monadAff),
      Functor0: function () {
          return functorAff;
      }
  };
  var applicativeAff = {
      pure: $foreign["_pure"],
      Apply0: function () {
          return applyAff;
      }
  };
  var monadEffectAff = {
      liftEffect: $foreign["_liftEffect"],
      Monad0: function () {
          return monadAff;
      }
  };
  exports["launchAff_"] = launchAff_;
  exports["applicativeAff"] = applicativeAff;
  exports["bindAff"] = bindAff;
  exports["monadEffectAff"] = monadEffectAff;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var semigroupoidFn = {
      compose: function (f) {
          return function (g) {
              return function (x) {
                  return f(g(x));
              };
          };
      }
  };
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = {
      identity: function (x) {
          return x;
      },
      Semigroupoid0: function () {
          return Control_Semigroupoid.semigroupoidFn;
      }
  };
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Effect.Class"] = $PS["Effect.Class"] || {};
  var exports = $PS["Effect.Class"];
  var Control_Category = $PS["Control.Category"];
  var Effect = $PS["Effect"];                
  var monadEffectEffect = {
      liftEffect: Control_Category.identity(Control_Category.categoryFn),
      Monad0: function () {
          return Effect.monadEffect;
      }
  };
  var liftEffect = function (dict) {
      return dict.liftEffect;
  };
  exports["liftEffect"] = liftEffect;
  exports["monadEffectEffect"] = monadEffectEffect;
})(PS);
(function(exports) {
  exports.innerHTML = function (node) {
    return function () {
      return node.innerHTML
    }
  }

  exports.setInnerHTML = function (innerHTML) {
    return function (node) {
      return function () {
        node.innerHTML = innerHTML
      }
    }
  }

  exports.ctrlKey = function (event) {
    return function () {
      return event.ctrlKey || event.metaKey
    }
  }
})(PS["HtmlExtra"] = PS["HtmlExtra"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["HtmlExtra"] = $PS["HtmlExtra"] || {};
  var exports = $PS["HtmlExtra"];
  var $foreign = $PS["HtmlExtra"];
  exports["innerHTML"] = $foreign.innerHTML;
  exports["setInnerHTML"] = $foreign.setInnerHTML;
  exports["ctrlKey"] = $foreign.ctrlKey;
})(PS);
(function(exports) {
  exports.placeholder = function (template) {
    return function (data) {
      /*!
     * Get an object value from a specific path
     * (c) 2018 Chris Ferdinandi, MIT License, https://gomakethings.com
     * @param  {Object}       obj  The object
     * @param  {String|Array} path The path
     * @param  {*}            def  A default value to return [optional]
     * @return {*}                 The value
     */  
      var get = function (obj, path, def) {
        /**
       * If the path is a string, convert it to an array
       * @param  {String|Array} path The path
       * @return {Array}             The path array
       */  
        var stringToPath = function (path) {
          // If the path isn't a string, return it
          if (typeof path !== 'string') return path

          // Create new array
          var output = []

          // Split to an array with dot notation
          path.split('.').forEach(function (item) {
            // Split to an array with bracket notation
            item.split(/\[([^}]+)\]/g).forEach(function (key) {
              // Push to the new array
              if (key.length > 0) {
                output.push(key)
              }
            })
          })

          return output
        }

        // Get the path as an array
        path = stringToPath(path)

        // Cache the current object
        var current = obj

        // For each item in the path, dig into the object
        for (var i = 0; i < path.length; i++) {
          // If the item isn't found, return the default (or null)
          if (!current[path[i]]) return def

          // Otherwise, update the current  value
          current = current[path[i]]
        }

        return current
      }
      // Replace our curly braces with data
      template = template.replace(/\[\[([^\]]+)\]\]/g, function (match) {
        // Remove the wrapping curly braces
        match = match.slice(2, -2)

        // Get the value
        var val = get(data, match.trim())

        // Replace
        if (!val) return '[[' + match + ']]'
        return val
      })

      return template
    }
  }
})(PS["Placeholder"] = PS["Placeholder"] || {});
(function($PS) {
  "use strict";
  $PS["Placeholder"] = $PS["Placeholder"] || {};
  var exports = $PS["Placeholder"];
  var $foreign = $PS["Placeholder"];
  var ProfileHtml = function (x) {
      return x;
  };
  var TestT = (function () {
      function TestT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      TestT.create = function (value0) {
          return function (value1) {
              return new TestT(value0, value1);
          };
      };
      return TestT;
  })();
  var NestedT = (function () {
      function NestedT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      NestedT.create = function (value0) {
          return function (value1) {
              return new NestedT(value0, value1);
          };
      };
      return NestedT;
  })();
  var ProfileT = (function () {
      function ProfileT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ProfileT.create = function (value0) {
          return function (value1) {
              return new ProfileT(value0, value1);
          };
      };
      return ProfileT;
  })();
  var OtherT = (function () {
      function OtherT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      OtherT.create = function (value0) {
          return function (value1) {
              return new OtherT(value0, value1);
          };
      };
      return OtherT;
  })();
  var ErrorT = (function () {
      function ErrorT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ErrorT.create = function (value0) {
          return function (value1) {
              return new ErrorT(value0, value1);
          };
      };
      return ErrorT;
  })();
  var ProductT = (function () {
      function ProductT(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ProductT.create = function (value0) {
          return function (value1) {
              return new ProductT(value0, value1);
          };
      };
      return ProductT;
  })();
  var templateInject = function (v) {
      if (v instanceof TestT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      if (v instanceof NestedT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      if (v instanceof ProfileT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      if (v instanceof OtherT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      if (v instanceof ErrorT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      if (v instanceof ProductT) {
          return $foreign.placeholder(v.value0)(v.value1);
      };
      throw new Error("Failed pattern match at Placeholder (line 31, column 1 - line 31, column 49): " + [ v.constructor.name ]);
  };
  exports["ProfileHtml"] = ProfileHtml;
  exports["NestedT"] = NestedT;
  exports["ProfileT"] = ProfileT;
  exports["ErrorT"] = ErrorT;
  exports["ProductT"] = ProductT;
  exports["templateInject"] = templateInject;
})(PS);
(function(exports) {
  "use strict";

  exports._getElementById = function (id) {
    return function (node) {
      return function () {
        return node.getElementById(id);
      };
    };
  };
})(PS["Web.DOM.NonElementParentNode"] = PS["Web.DOM.NonElementParentNode"] || {});
(function(exports) {
  /* eslint-disable no-eq-null, eqeqeq */

  "use strict";          

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Nullable"] = $PS["Data.Nullable"] || {};
  var exports = $PS["Data.Nullable"];
  var $foreign = $PS["Data.Nullable"];
  var Data_Maybe = $PS["Data.Maybe"];                                   
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.DOM.NonElementParentNode"] = $PS["Web.DOM.NonElementParentNode"] || {};
  var exports = $PS["Web.DOM.NonElementParentNode"];
  var $foreign = $PS["Web.DOM.NonElementParentNode"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Nullable = $PS["Data.Nullable"];
  var Effect = $PS["Effect"];                
  var getElementById = function (eid) {
      var $0 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);
      var $1 = $foreign["_getElementById"](eid);
      return function ($2) {
          return $0($1($2));
      };
  };
  exports["getElementById"] = getElementById;
})(PS);
(function(exports) {
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["Web.HTML"] = PS["Web.HTML"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.HTML"] = $PS["Web.HTML"] || {};
  var exports = $PS["Web.HTML"];
  var $foreign = $PS["Web.HTML"];
  exports["window"] = $foreign.window;
})(PS);
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.HTML.HTMLDocument"] = $PS["Web.HTML.HTMLDocument"] || {};
  var exports = $PS["Web.HTML.HTMLDocument"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];     
  var toNonElementParentNode = Unsafe_Coerce.unsafeCoerce;
  var toEventTarget = Unsafe_Coerce.unsafeCoerce;
  exports["toNonElementParentNode"] = toNonElementParentNode;
  exports["toEventTarget"] = toEventTarget;
})(PS);
(function(exports) {
  "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
})(PS["Web.HTML.Window"] = PS["Web.HTML.Window"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.HTML.Window"] = $PS["Web.HTML.Window"] || {};
  var exports = $PS["Web.HTML.Window"];
  var $foreign = $PS["Web.HTML.Window"];
  exports["document"] = $foreign.document;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Clack"] = $PS["Clack"] || {};
  var exports = $PS["Clack"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var CustomEvent = $PS["CustomEvent"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Dompurify = $PS["Dompurify"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var HtmlExtra = $PS["HtmlExtra"];
  var Placeholder = $PS["Placeholder"];
  var Web_DOM_NonElementParentNode = $PS["Web.DOM.NonElementParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var clack = function (v) {
      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
          var document_ = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))((function () {
              var $5 = Control_Applicative.pure(Effect.applicativeEffect);
              return function ($6) {
                  return $5(Web_HTML_HTMLDocument.toNonElementParentNode($6));
              };
          })())();
          var getById = function (str) {
              return Web_DOM_NonElementParentNode.getElementById(str)(document_);
          };
          var box_ = getById("box")();
          var template_ = getById("test-template")();
          if (box_ instanceof Data_Maybe.Just && template_ instanceof Data_Maybe.Just) {
              var html = HtmlExtra.innerHTML(template_.value0)();
              var html_ = Dompurify.sanitize(Placeholder.templateInject(new Placeholder.NestedT(html, {
                  profile: {
                      name: "Daniel"
                  },
                  so: "oau"
              })))();
              return HtmlExtra.setInnerHTML(html_)(box_.value0)();
          };
          if (box_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("box"))();
          };
          if (template_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("test-template"))();
          };
          throw new Error("Failed pattern match at Clack (line 28, column 3 - line 34, column 57): " + [ box_.constructor.name, template_.constructor.name ]);
      });
  };
  exports["clack"] = clack;
})(PS);
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];      
  var foldr = function (dict) {
      return dict.foldr;
  };
  var foldl = function (dict) {
      return dict.foldl;
  };
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = {
      foldr: $foreign.foldrArray,
      foldl: $foreign.foldlArray,
      foldMap: function (dictMonoid) {
          return foldMapDefaultR(foldableArray)(dictMonoid);
      }
  };
  exports["foldl"] = foldl;
  exports["foldableArray"] = foldableArray;
})(PS);
(function(exports) {
  "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var showInt = {
      show: $foreign.showIntImpl
  };
  var show = function (dict) {
      return dict.show;
  };
  exports["show"] = show;
  exports["showInt"] = showInt;
})(PS);
(function(exports) {
  "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
    };
  };

  exports.error = function (s) {
    return function () {
      console.error(s);
    };
  };
})(PS["Effect.Console"] = PS["Effect.Console"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Effect.Console"] = $PS["Effect.Console"] || {};
  var exports = $PS["Effect.Console"];
  var $foreign = $PS["Effect.Console"];
  exports["log"] = $foreign.log;
  exports["error"] = $foreign.error;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["ErrorEvent"] = $PS["ErrorEvent"] || {};
  var exports = $PS["ErrorEvent"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var CustomEvent = $PS["CustomEvent"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Dompurify = $PS["Dompurify"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var HtmlExtra = $PS["HtmlExtra"];
  var Placeholder = $PS["Placeholder"];
  var Web_DOM_NonElementParentNode = $PS["Web.DOM.NonElementParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var errorEvent = function (v) {
      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
          var document_ = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))((function () {
              var $5 = Control_Applicative.pure(Effect.applicativeEffect);
              return function ($6) {
                  return $5(Web_HTML_HTMLDocument.toNonElementParentNode($6));
              };
          })())();
          var getById = function (str) {
              return Web_DOM_NonElementParentNode.getElementById(str)(document_);
          };
          var box_ = getById("error")();
          var template_ = getById("error-templatea")();
          if (box_ instanceof Data_Maybe.Just && template_ instanceof Data_Maybe.Just) {
              var html = HtmlExtra.innerHTML(template_.value0)();
              var html_ = Dompurify.sanitize(Placeholder.templateInject(new Placeholder.ErrorT(html, {
                  error: "Missing something, raised error",
                  description: "try something else"
              })))();
              return HtmlExtra.setInnerHTML(html_)(box_.value0)();
          };
          if (box_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("error"))();
          };
          if (template_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("error-template"))();
          };
          throw new Error("Failed pattern match at ErrorEvent (line 27, column 3 - line 33, column 58): " + [ box_.constructor.name, template_.constructor.name ]);
      });
  };
  exports["errorEvent"] = errorEvent;
})(PS);
(function(exports) {
  "use strict";

  exports._getAttribute = function (name) {
    return function (element) {
      return function () {
        return element.getAttribute(name);
      };
    };
  };

  exports.matches = function (selector) {
    return function(element) {
      return function () {
        return element.matches(selector);
      };
    };
  };
})(PS["Web.DOM.Element"] = PS["Web.DOM.Element"] || {});
(function(exports) {
  "use strict";

  exports._unsafeReadProtoTagged = function (nothing, just, name, value) {
    if (typeof window !== "undefined") {
      var ty = window[name];
      if (ty != null && value instanceof ty) {
        return just(value);
      }
    }
    var obj = value;
    while (obj != null) {
      var proto = Object.getPrototypeOf(obj);
      var constructorName = proto.constructor.name;
      if (constructorName === name) {
        return just(value);
      } else if (constructorName === "Object") {
        return nothing;
      }
      obj = proto;
    }
    return nothing;
  };
})(PS["Web.Internal.FFI"] = PS["Web.Internal.FFI"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.Internal.FFI"] = $PS["Web.Internal.FFI"] || {};
  var exports = $PS["Web.Internal.FFI"];
  var $foreign = $PS["Web.Internal.FFI"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var unsafeReadProtoTagged = function (name) {
      return function (value) {
          return $foreign["_unsafeReadProtoTagged"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, name, value);
      };
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.DOM.Element"] = $PS["Web.DOM.Element"] || {};
  var exports = $PS["Web.DOM.Element"];
  var $foreign = $PS["Web.DOM.Element"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Nullable = $PS["Data.Nullable"];
  var Effect = $PS["Effect"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];
  var getAttribute = function (attr) {
      var $3 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);
      var $4 = $foreign["_getAttribute"](attr);
      return function ($5) {
          return $3($4($5));
      };
  };                                                               
  var fromEventTarget = Web_Internal_FFI.unsafeReadProtoTagged("Element");
  exports["fromEventTarget"] = fromEventTarget;
  exports["getAttribute"] = getAttribute;
  exports["matches"] = $foreign.matches;
})(PS);
(function(exports) {
  "use strict";

  exports._target = function (e) {
    return e.target;
  };

  exports.preventDefault = function (e) {
    return function () {
      return e.preventDefault();
    };
  };
})(PS["Web.Event.Event"] = PS["Web.Event.Event"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.Event.Event"] = $PS["Web.Event.Event"] || {};
  var exports = $PS["Web.Event.Event"];
  var $foreign = $PS["Web.Event.Event"];
  var Data_Nullable = $PS["Data.Nullable"];
  var target = function ($1) {
      return Data_Nullable.toMaybe($foreign["_target"]($1));
  };
  exports["target"] = target;
  exports["preventDefault"] = $foreign.preventDefault;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Event"] = $PS["Event"] || {};
  var exports = $PS["Event"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var Web_DOM_Element = $PS["Web.DOM.Element"];
  var Web_Event_Event = $PS["Web.Event.Event"];                
  var isSelectorEvent = function (evt) {
      return function (selector) {
          var v = Control_Bind.bindFlipped(Data_Maybe.bindMaybe)(Web_DOM_Element.fromEventTarget)(Web_Event_Event.target(evt));
          if (v instanceof Data_Maybe.Nothing) {
              return Control_Applicative.pure(Effect_Aff.applicativeAff)(false);
          };
          if (v instanceof Data_Maybe.Just) {
              return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Web_DOM_Element.matches(selector)(v.value0));
          };
          throw new Error("Failed pattern match at Event (line 15, column 3 - line 17, column 70): " + [ v.constructor.name ]);
      };
  };
  exports["isSelectorEvent"] = isSelectorEvent;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Hack"] = $PS["Hack"] || {};
  var exports = $PS["Hack"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var CustomEvent = $PS["CustomEvent"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Dompurify = $PS["Dompurify"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var HtmlExtra = $PS["HtmlExtra"];
  var Placeholder = $PS["Placeholder"];
  var Web_DOM_NonElementParentNode = $PS["Web.DOM.NonElementParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var fnT = function (acc) {
      return function (item) {
          return acc + Placeholder.templateInject(item);
      };
  };
  var fn = function (html) {
      return function (acc) {
          return function (item) {
              return fnT(acc)(new Placeholder.ProfileT(html, item));
          };
      };
  };
  var hack = function (v) {
      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
          var document_ = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))((function () {
              var $5 = Control_Applicative.pure(Effect.applicativeEffect);
              return function ($6) {
                  return $5(Web_HTML_HTMLDocument.toNonElementParentNode($6));
              };
          })())();
          var getById = function (str) {
              return Web_DOM_NonElementParentNode.getElementById(str)(document_);
          };
          var box_ = getById("ul")();
          var template_ = getById("template-item")();
          var arr = [ {
              name: "Dan",
              surname: "Stale"
          }, {
              name: "Druhy",
              surname: "User"
          } ];
          if (box_ instanceof Data_Maybe.Just && template_ instanceof Data_Maybe.Just) {
              var html = Control_Bind.bind(Effect.bindEffect)(HtmlExtra.innerHTML(template_.value0))((function () {
                  var $7 = Control_Applicative.pure(Effect.applicativeEffect);
                  return function ($8) {
                      return $7(Placeholder.ProfileHtml($8));
                  };
              })())();
              var html$prime = Dompurify.sanitize(Data_Foldable.foldl(Data_Foldable.foldableArray)(fn(html))("")(arr))();
              return HtmlExtra.setInnerHTML(html$prime)(box_.value0)();
          };
          if (box_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("ul"))();
          };
          if (template_ instanceof Data_Maybe.Nothing) {
              return CustomEvent.err(CustomEvent.elemNotFound("template-item"))();
          };
          throw new Error("Failed pattern match at Hack (line 33, column 3 - line 41, column 57): " + [ box_.constructor.name, template_.constructor.name ]);
      });
  };
  exports["hack"] = hack;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["IfThen"] = $PS["IfThen"] || {};
  var exports = $PS["IfThen"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Data_Unit = $PS["Data.Unit"];                
  var ifThen = function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (!v1) {
                  return Control_Applicative.pure(dictApplicative)(Data_Unit.unit);
              };
              if (v1) {
                  return v;
              };
              throw new Error("Failed pattern match at IfThen (line 5, column 1 - line 5, column 66): " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };
  exports["ifThen"] = ifThen;
})(PS);
(function($PS) {
  "use strict";
  $PS["ProductShow"] = $PS["ProductShow"] || {};
  var exports = $PS["ProductShow"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var CustomEvent = $PS["CustomEvent"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Show = $PS["Data.Show"];
  var Dompurify = $PS["Dompurify"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var HtmlExtra = $PS["HtmlExtra"];
  var Placeholder = $PS["Placeholder"];
  var Web_DOM_NonElementParentNode = $PS["Web.DOM.NonElementParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var productShow = function (n) {
      return function (v) {
          return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {
              var document_ = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))((function () {
                  var $5 = Control_Applicative.pure(Effect.applicativeEffect);
                  return function ($6) {
                      return $5(Web_HTML_HTMLDocument.toNonElementParentNode($6));
                  };
              })())();
              var getById = function (str) {
                  return Web_DOM_NonElementParentNode.getElementById(str)(document_);
              };
              var box_ = getById("box")();
              var template_ = getById("product-template")();
              if (box_ instanceof Data_Maybe.Just && template_ instanceof Data_Maybe.Just) {
                  var html = HtmlExtra.innerHTML(template_.value0)();
                  var html_ = Dompurify.sanitize(Placeholder.templateInject(new Placeholder.ProductT(html, {
                      product: {
                          title: "Product title " + Data_Show.show(Data_Show.showInt)(n),
                          description: "Description of the product " + Data_Show.show(Data_Show.showInt)(n)
                      }
                  })))();
                  return HtmlExtra.setInnerHTML(html_)(box_.value0)();
              };
              if (box_ instanceof Data_Maybe.Nothing) {
                  return CustomEvent.err(CustomEvent.elemNotFound("box"))();
              };
              if (template_ instanceof Data_Maybe.Nothing) {
                  return CustomEvent.err({
                      error: "Fix your html",
                      description: "'product-template' id not found in your html!"
                  })();
              };
              throw new Error("Failed pattern match at ProductShow (line 28, column 3 - line 34, column 109): " + [ box_.constructor.name, template_.constructor.name ]);
          });
      };
  };
  exports["productShow"] = productShow;
})(PS);
(function(exports) {
  exports.fetchHtmlAndRender = function (url) {
    return function () {
      if (
        url === window.location.pathname ||
        '/' + url === window.location.pathname
      )
        return
      return fetch(url)
        .then((res) => res.text())
        .then((ctx) => {
          const html = new DOMParser().parseFromString(ctx, 'text/html')
          document.head.innerHTML = html.head.innerHTML
          document.body.innerHTML = html.body.innerHTML
          history.pushState(history.state, document.title, url)
        })
        .catch(console.log)
    }
  }

  exports.loadPage = function () {
    return fetch(window.location.href)
      .then((res) => res.text())
      .then((ctx) => {
        const html = new DOMParser().parseFromString(ctx, 'text/html')
        document.head.innerHTML = html.head.innerHTML
        document.body.innerHTML = html.body.innerHTML
      })
      .catch(console.log)
  }

  exports.windowTarget = function () {
    return window
  }
})(PS["Test"] = PS["Test"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Test"] = $PS["Test"] || {};
  var exports = $PS["Test"];
  var $foreign = $PS["Test"];
  exports["fetchHtmlAndRender"] = $foreign.fetchHtmlAndRender;
  exports["loadPage"] = $foreign.loadPage;
  exports["windowTarget"] = $foreign.windowTarget;
})(PS);
(function(exports) {
  "use strict";

  exports.eventListener = function (fn) {
    return function () {
      return function (event) {
        return fn(event)();
      };
    };
  };

  exports.addEventListener = function (type) {
    return function (listener) {
      return function (useCapture) {
        return function (target) {
          return function () {
            return target.addEventListener(type, listener, useCapture);
          };
        };
      };
    };
  };
})(PS["Web.Event.EventTarget"] = PS["Web.Event.EventTarget"] || {});
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.Event.EventTarget"] = $PS["Web.Event.EventTarget"] || {};
  var exports = $PS["Web.Event.EventTarget"];
  var $foreign = $PS["Web.Event.EventTarget"];
  exports["eventListener"] = $foreign.eventListener;
  exports["addEventListener"] = $foreign.addEventListener;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.HTML.Event.EventTypes"] = $PS["Web.HTML.Event.EventTypes"] || {};
  var exports = $PS["Web.HTML.Event.EventTypes"];
  var click = "click";
  exports["click"] = click;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Web.HTML.HTMLAnchorElement"] = $PS["Web.HTML.HTMLAnchorElement"] || {};
  var exports = $PS["Web.HTML.HTMLAnchorElement"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];
  var toElement = Unsafe_Coerce.unsafeCoerce;                                       
  var fromEventTarget = Web_Internal_FFI.unsafeReadProtoTagged("HTMLAnchorElement");
  exports["fromEventTarget"] = fromEventTarget;
  exports["toElement"] = toElement;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["EventListeners"] = $PS["EventListeners"] || {};
  var exports = $PS["EventListeners"];
  var Clack = $PS["Clack"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var CustomEvent = $PS["CustomEvent"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Unit = $PS["Data.Unit"];
  var Dompurify = $PS["Dompurify"];
  var Effect = $PS["Effect"];
  var Effect_Aff = $PS["Effect.Aff"];
  var Effect_Class = $PS["Effect.Class"];
  var Effect_Console = $PS["Effect.Console"];
  var ErrorEvent = $PS["ErrorEvent"];
  var Event = $PS["Event"];
  var Hack = $PS["Hack"];
  var HtmlExtra = $PS["HtmlExtra"];
  var IfThen = $PS["IfThen"];
  var Placeholder = $PS["Placeholder"];
  var ProductShow = $PS["ProductShow"];
  var Test = $PS["Test"];
  var Web_DOM_Element = $PS["Web.DOM.Element"];
  var Web_DOM_NonElementParentNode = $PS["Web.DOM.NonElementParentNode"];
  var Web_Event_Event = $PS["Web.Event.Event"];
  var Web_Event_EventTarget = $PS["Web.Event.EventTarget"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_Event_EventTypes = $PS["Web.HTML.Event.EventTypes"];
  var Web_HTML_HTMLAnchorElement = $PS["Web.HTML.HTMLAnchorElement"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var popstateEventListeners = function (evt) {
      return Test.loadPage;
  };
  var errorListeners = function (evt) {
      return Effect_Aff.launchAff_(Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document))((function () {
          var $10 = Control_Applicative.pure(Effect.applicativeEffect);
          return function ($11) {
              return $10(Web_HTML_HTMLDocument.toNonElementParentNode($11));
          };
      })())))(function (document_) {
          var getById = function (str) {
              return Effect_Class.liftEffect(Effect_Class.monadEffectEffect)(Web_DOM_NonElementParentNode.getElementById(str)(document_));
          };
          return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(getById("error")))(function (box_) {
              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(getById("error-template")))(function (template_) {
                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)((function () {
                      if (box_ instanceof Data_Maybe.Just && template_ instanceof Data_Maybe.Just) {
                          return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(HtmlExtra.innerHTML(template_.value0)))(function (html) {
                              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Dompurify.sanitize(Placeholder.templateInject(new Placeholder.ErrorT(html, CustomEvent.detail(evt))))))(function (html_) {
                                  return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(HtmlExtra.setInnerHTML(html_)(box_.value0));
                              });
                          });
                      };
                      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Console.error("Error logging broken!!"));
                  })())(function () {
                      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(CustomEvent.logAny(CustomEvent.detail(evt)));
                  });
              });
          });
      }));
  };
  var cluck = function (v) {
      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Console.log("cluck"));
  };
  var clickAnchor = function (evt) {
      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(HtmlExtra.ctrlKey(evt)))(function (isCtrl) {
          if (isCtrl) {
              return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit);
          };
          if (!isCtrl) {
              return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Web_Event_Event.preventDefault(evt)))(function () {
                  var a_ = Control_Bind.bind(Data_Maybe.bindMaybe)(Web_Event_Event.target(evt))(Web_HTML_HTMLAnchorElement.fromEventTarget);
                  if (a_ instanceof Data_Maybe.Just) {
                      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Web_DOM_Element.getAttribute("href")(Web_HTML_HTMLAnchorElement.toElement(a_.value0))))(function (str_) {
                          if (str_ instanceof Data_Maybe.Just) {
                              return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Test.fetchHtmlAndRender(str_.value0));
                          };
                          if (str_ instanceof Data_Maybe.Nothing) {
                              return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit);
                          };
                          throw new Error("Failed pattern match at EventListeners (line 48, column 11 - line 51, column 33): " + [ str_.constructor.name ]);
                      });
                  };
                  if (a_ instanceof Data_Maybe.Nothing) {
                      return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit);
                  };
                  throw new Error("Failed pattern match at EventListeners (line 45, column 7 - line 52, column 29): " + [ a_.constructor.name ]);
              });
          };
          throw new Error("Failed pattern match at EventListeners (line 40, column 3 - line 52, column 29): " + [ isCtrl.constructor.name ]);
      });
  };
  var clickEventListeners = function (evt) {
      return Effect_Aff.launchAff_((function () {
          var isSelector = Event.isSelectorEvent(evt);
          return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[href]"))(IfThen.ifThen(Effect_Aff.applicativeAff)(clickAnchor(evt))))(function () {
              return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='clack']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(Clack.clack(evt))))(function () {
                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='cluck']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(cluck(evt))))(function () {
                      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='hack']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(Hack.hack(evt))))(function () {
                          return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='hack']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(ErrorEvent.errorEvent(evt))))(function () {
                              return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='product2']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(ProductShow.productShow(2)(evt))))(function () {
                                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='product3']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(ProductShow.productShow(3)(evt))))(function () {
                                      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='product4']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(ProductShow.productShow(4)(evt))))(function () {
                                          return Control_Bind.bind(Effect_Aff.bindAff)(isSelector("[click='product5']"))(IfThen.ifThen(Effect_Aff.applicativeAff)(ProductShow.productShow(5)(evt)));
                                      });
                                  });
                              });
                          });
                      });
                  });
              });
          });
      })());
  };
  var addEventListeners = function __do() {
      var clickEventListeners_ = Web_Event_EventTarget.eventListener(clickEventListeners)();
      var errorEventListeners = Web_Event_EventTarget.eventListener(errorListeners)();
      var popstateEventListeners_ = Web_Event_EventTarget.eventListener(popstateEventListeners)();
      var window_ = Test.windowTarget();
      var document_ = Control_Bind.bind(Effect.bindEffect)(Web_HTML.window)(Web_HTML_Window.document)();
      Web_Event_EventTarget.addEventListener(Web_HTML_Event_EventTypes.click)(clickEventListeners_)(false)(Web_HTML_HTMLDocument.toEventTarget(document_))();
      Web_Event_EventTarget.addEventListener("error-custom")(errorEventListeners)(false)(Web_HTML_HTMLDocument.toEventTarget(document_))();
      return Web_Event_EventTarget.addEventListener("popstate")(popstateEventListeners_)(false)(window_)();
  };
  exports["addEventListeners"] = addEventListeners;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.4
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var Effect_Console = $PS["Effect.Console"];
  var EventListeners = $PS["EventListeners"];                
  var main = function __do() {
      Effect_Console.log("works log")();
      return EventListeners.addEventListeners();
  };
  exports["main"] = main;
})(PS);
PS["Main"].main();